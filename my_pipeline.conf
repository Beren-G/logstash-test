input {
  beats {
    port => "5045"
  }
}

filter {
  #set log file name as source instead of full path
  grok {
          match => { "source" => "^(.+)\/(?<source>[^\/]+)$" }
          overwrite => [ "source" ]
  }

  #store un-parsed message in raw_message for testing
  mutate {
      copy => {"[@metadata][ip_address]" => "[beat][ip_address]"}
      copy => { "message" => "raw_message" }
  }
  # check if this is a status message, if so process it
  if [source] =~ /status_[\d_]*\.json$/ {
        mutate {
          add_field => { "test" => "Source: %{source}" }
        }
        
        grok {
            match => { "message" => "[\\d_]* +%{GREEDYDATA:json}" }
        }
        json {
          source => "json"
          target => "dynamic_json_field"
        }
        mutate {
            replace => { "[fields][log]" => "status" }
            replace => { "message" => "status_update" }
            rename =>  { "dynamic_json_field" => "%{[fields][type]}-status" }
        }
  }
  else
  {
    # Check if JSON found, if so parse it then remove it
    if [message] =~ /(?m)\{\s+?\"[\w\d]+\"\s*?:\s*?\{.*\}/ {
      grok {
        # matches json starting with curly bracket, whitespace, quote, words/digits, quote, colon. Quotes are escaped.
            match => { "message" => "\A(?<message>[^\{]+)\s+?(?m)(?<json>(\{\s*\"[\w\d]+\":\s*.*\}))" }
            overwrite => [ "message" ]
        }
      json {
        source => "json"
        target => "dynamic_json_field"
      }
      mutate {
        gsub => [ "message", "(?m).*?(\{.+\})", "" ]
        remove_field => [ "json" ]
        add_tag => [ "json" ]
        }
    }

    # Process different types of logs
    if [fields][log] == "nuberlog" {
      grok {
              match => { "message" => "(?<ts>%{YEAR}-%{MONTHNUM}-%{MONTHDAY} %{HOUR}:?%{MINUTE}.(?<sec>[0-5]?[0-9]|60)[:.,](?<ms>[0-9]+)) +\[%{LOGLEVEL:loglevel}\] (?<filename>.+?(?=@))@(?<line_number>(?<=@)[0-9]*) (?<function>\S*) (?m)%{GREEDYDATA:message}" }
              overwrite => [ "message" ]
      }

      if [message] =~ /Setting player key to:/ {
        grok {
          match => { "message" => "Setting player key to: %{WORD:player_key}" }
        }
      }

      mutate {
              gsub => [ "ts", ".{3}$", "" ]
          convert => {
                  "ms" => "integer"
              }
              #add_tag => [ "%{function}", "%{filename}@%{line_number}", "%{loglevel}" ]
            remove_field => [ "ts", "sec" ]
      }
      date {
        match => [ "ts", "yyyy-MM-dd HH:mm:ss.SSS" ]
      }
    }
    # Now that function field is populated, change root JSON object to function name.
    if [dynamic_json_field] {
      mutate {
        rename => { "dynamic_json_field" => "%{function}" }
      }

    }
  }
}

output {
  stdout { codec => rubydebug }
}
