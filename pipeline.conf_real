input { 
	beats {
		port => "5044"
	 } 
} 
output { 
	stdout {} 
}


filter {
	# get log file name
	grok {
	        match => { "source" => "^(.+)\/(?<log_file>[^\/]+)$" }
	        #overwrite => [ "source" ]
	}

	# store un-parsed message in raw_message for testing
	mutate {
	        copy => { "message" => "raw_message" }
	}

	# main log parsing
	grok {
	        match => { "message" => "(?<ts>%{YEAR}-%{MONTHNUM}-%{MONTHDAY} %{HOUR}:?%{MINUTE}.(?<sec>[0-5]?[0-9]|60)[:.,](?<ms>[0-9]+)) +\[%{LOGLEVEL:loglevel}\] (?<filename>.+?(?=@))@(?<line_number>(?<=@)[0-9]*) (?<function>\S*) (?m)%{GREEDYDATA:message}" }
	        overwrite => [ "message" ]
	}
	if [message] =~ /(?m).*?(\{.+\})/ {
		grok {
	        	match => { "message" => "(?<message>\A[\s\d\w]+)?[^\{] +(?m)%{GREEDYDATA:json}"}
			overwrite => [ "message" ]
    		}
		json {
			source => "json"
			target => "dynamic_json_field"
		}
		mutate {
			rename => { "dynamic_json_field" => "%{function}" }
    		}
		}	

	# custom fields
	if [message] =~ /Setting player key to:/ {
		grok {
			match => { "message" => "Setting player key to: %{WORD:player_key}" }
		}
	}
	
	# truncate 6 character milliseconds to 3 to pass to date{}
	mutate {
	        gsub => [ "ts", ".{3}$", "" ]
			convert => {
	            "ms" => "integer"
	        }
	        add_tag => [ "%{function}", "%{filename}@%{line_number}", "%{loglevel}" ]
    		remove_field => [ "ts", "sec", "json" ]
	}
	date {
		match => [ "ts", "yyyy-MM-dd HH:mm:ss.SSS" ]
	}

}
